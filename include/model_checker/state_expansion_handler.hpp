/*
 * Copyright (c) 2024 Robert Bosch GmbH and its subsidiaries
 *
 * This file is part of smc_storm.
 *
 * smc_storm is free software: you can redistribute it and/or modify it under the terms of
 * the GNU General Public License as published by the Free Software Foundation, either
 * version 3 of the License, or (at your option) any later version.
 *
 * smc_storm is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with smc_storm.
 * If not, see <https://www.gnu.org/licenses/>.
 */

#pragma once

#include <memory>

#include <storm/generator/CompressedState.h>
#include <storm/storage/sparse/StateStorage.h>

#include "samples/exploration_information.hpp"

namespace smc_storm {
namespace model_checker {

/*!
 * @brief Class that loads an input model and property to generate states and verify if the input property holds.
 * @tparam StateType Variable type to identify states and actions
 * @tparam ValueType Variable type of computed results (e.g. rewards)
 */
template <typename StateType, typename ValueType>
class StateExpansionHandler {
  public:
    StateExpansionHandler();

    /*!
     * @brief Init the state storage structures, if required
     * @param state_size the dimension of the model's state
     */
    void init(const uint64_t state_size);

    /*!
     * @brief Callback to process the next states from the one under expansion. It must assign a numeric ID to them
     * @param state The state ID to process
     * @return The int ID associated to the processed next state
     */
    uint32_t stateExpansionCallback(const storm::generator::CompressedState& state);
};

template <typename ValueType>
class StateExpansionHandler<storm::generator::CompressedState, ValueType> {
  private:
    std::vector<storm::generator::CompressedState> _next_states;
    const storm::storage::Murmur3BitVectorHash<uint32_t> _hash_f;

  public:
    StateExpansionHandler() : _hash_f(storm::storage::Murmur3BitVectorHash<uint32_t>{}) {}

    void init([[maybe_unused]] const uint64_t state_size) {}

    uint32_t stateExpansionCallback(const storm::generator::CompressedState& state) {
        const uint32_t state_id = _next_states.size();
        _next_states.emplace_back(state);
        return state_id;
    }

    /*!
     * @brief Get the next states generated by the last state expansion
     * @return The next states generated by the last state expansion
     */
    inline const std::vector<storm::generator::CompressedState>& getNextStates() const {
        return _next_states;
    }

    /*!
     * @brief Clear the next states generated by the last state expansion
     */
    inline void clearNextStates() {
        _next_states.clear();
    }

    /*!
     * @brief Get the hash value of the compressed state
     * @param compressed_state The compressed state to hash
     * @return The hash value of the compressed state
     */
    inline const uint32_t getHashValue(const storm::generator::CompressedState& compressed_state) const {
        return _hash_f(compressed_state);
    }
};

template <typename ValueType>
class StateExpansionHandler<uint32_t, ValueType> {
  private:
    std::unique_ptr<storm::storage::sparse::StateStorage<uint32_t>> _state_storage_ptr;
    samples::ExplorationInformation<uint32_t, ValueType> _exploration_information;

  public:
    StateExpansionHandler() {}

    void init(const uint64_t state_size) {
        _state_storage_ptr = std::make_unique<storm::storage::sparse::StateStorage<uint32_t>>(state_size);
    }

    uint32_t stateExpansionCallback(const storm::generator::CompressedState& state) {
        uint32_t new_index = _state_storage_ptr->getNumberOfStates();
        // Check, if the state was already registered.
        std::pair<uint32_t, std::size_t> actual_index_bucket_pair = (_state_storage_ptr->stateToId).findOrAddAndGetBucket(state, new_index);

        if (actual_index_bucket_pair.first == new_index) {
            _exploration_information.addUnexploredState(new_index, state);
        }
        return actual_index_bucket_pair.first;
    }

    /*!
     * @brief Get the reference to the previous explored states container
     * @return ExplorationInformation instance
     */
    samples::ExplorationInformation<uint32_t, ValueType>& getExplorationInformation() {
        return _exploration_information;
    }
};

}  // namespace model_checker
}  // namespace smc_storm
